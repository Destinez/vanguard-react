{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nimport compare from './tools/semver-compare.js'; // Added \"possibleLengths\" and renamed\n// \"country_phone_code_to_countries\" to \"country_calling_codes\".\n\nvar V2 = '1.0.18'; // Added \"idd_prefix\" and \"default_idd_prefix\".\n\nvar V3 = '1.2.0'; // Moved `001` country code to \"nonGeographic\" section of metadata.\n\nvar V4 = '1.7.35';\nvar DEFAULT_EXT_PREFIX = ' ext. ';\nvar CALLING_CODE_REG_EXP = /^\\d+$/;\n/**\r\n * See: https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md\r\n */\n\nvar Metadata = /*#__PURE__*/function () {\n  function Metadata(metadata) {\n    _classCallCheck(this, Metadata);\n\n    validateMetadata(metadata);\n    this.metadata = metadata;\n    setVersion.call(this, metadata);\n  }\n\n  _createClass(Metadata, [{\n    key: \"getCountries\",\n    value: function getCountries() {\n      return Object.keys(this.metadata.countries).filter(function (_) {\n        return _ !== '001';\n      });\n    }\n  }, {\n    key: \"getCountryMetadata\",\n    value: function getCountryMetadata(countryCode) {\n      return this.metadata.countries[countryCode];\n    }\n  }, {\n    key: \"nonGeographic\",\n    value: function nonGeographic() {\n      if (this.v1 || this.v2 || this.v3) return; // `nonGeographical` was a typo.\n      // It's present in metadata generated from `1.7.35` to `1.7.37`.\n      // The test case could be found by searching for \"nonGeographical\".\n\n      return this.metadata.nonGeographic || this.metadata.nonGeographical;\n    }\n  }, {\n    key: \"hasCountry\",\n    value: function hasCountry(country) {\n      return this.getCountryMetadata(country) !== undefined;\n    }\n  }, {\n    key: \"hasCallingCode\",\n    value: function hasCallingCode(callingCode) {\n      if (this.getCountryCodesForCallingCode(callingCode)) {\n        return true;\n      }\n\n      if (this.nonGeographic()) {\n        if (this.nonGeographic()[callingCode]) {\n          return true;\n        }\n      } else {\n        // A hacky workaround for old custom metadata (generated before V4).\n        var countryCodes = this.countryCallingCodes()[callingCode];\n\n        if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {\n          return true;\n        }\n      }\n    }\n  }, {\n    key: \"isNonGeographicCallingCode\",\n    value: function isNonGeographicCallingCode(callingCode) {\n      if (this.nonGeographic()) {\n        return this.nonGeographic()[callingCode] ? true : false;\n      } else {\n        return this.getCountryCodesForCallingCode(callingCode) ? false : true;\n      }\n    } // Deprecated.\n\n  }, {\n    key: \"country\",\n    value: function country(countryCode) {\n      return this.selectNumberingPlan(countryCode);\n    }\n  }, {\n    key: \"selectNumberingPlan\",\n    value: function selectNumberingPlan(countryCode, callingCode) {\n      // Supports just passing `callingCode` as the first argument.\n      if (countryCode && CALLING_CODE_REG_EXP.test(countryCode)) {\n        callingCode = countryCode;\n        countryCode = null;\n      }\n\n      if (countryCode && countryCode !== '001') {\n        if (!this.hasCountry(countryCode)) {\n          throw new Error(\"Unknown country: \".concat(countryCode));\n        }\n\n        this.numberingPlan = new NumberingPlan(this.getCountryMetadata(countryCode), this);\n      } else if (callingCode) {\n        if (!this.hasCallingCode(callingCode)) {\n          throw new Error(\"Unknown calling code: \".concat(callingCode));\n        }\n\n        this.numberingPlan = new NumberingPlan(this.getNumberingPlanMetadata(callingCode), this);\n      } else {\n        this.numberingPlan = undefined;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getCountryCodesForCallingCode\",\n    value: function getCountryCodesForCallingCode(callingCode) {\n      var countryCodes = this.countryCallingCodes()[callingCode];\n\n      if (countryCodes) {\n        // Metadata before V4 included \"non-geographic entity\" calling codes\n        // inside `country_calling_codes` (for example, `\"881\":[\"001\"]`).\n        // Now the semantics of `country_calling_codes` has changed:\n        // it's specifically for \"countries\" now.\n        // Older versions of custom metadata will simply skip parsing\n        // \"non-geographic entity\" phone numbers with new versions\n        // of this library: it's not considered a bug,\n        // because such numbers are extremely rare,\n        // and developers extremely rarely use custom metadata.\n        if (countryCodes.length === 1 && countryCodes[0].length === 3) {\n          return;\n        }\n\n        return countryCodes;\n      }\n    }\n  }, {\n    key: \"getCountryCodeForCallingCode\",\n    value: function getCountryCodeForCallingCode(callingCode) {\n      var countryCodes = this.getCountryCodesForCallingCode(callingCode);\n\n      if (countryCodes) {\n        return countryCodes[0];\n      }\n    }\n  }, {\n    key: \"getNumberingPlanMetadata\",\n    value: function getNumberingPlanMetadata(callingCode) {\n      var countryCode = this.getCountryCodeForCallingCode(callingCode);\n\n      if (countryCode) {\n        return this.getCountryMetadata(countryCode);\n      }\n\n      if (this.nonGeographic()) {\n        var metadata = this.nonGeographic()[callingCode];\n\n        if (metadata) {\n          return metadata;\n        }\n      } else {\n        // A hacky workaround for old custom metadata (generated before V4).\n        // In that metadata, there was no concept of \"non-geographic\" metadata\n        // so metadata for `001` country code was stored along with other countries.\n        // The test case can be found by searching for:\n        // \"should work around `nonGeographic` metadata not existing\".\n        var countryCodes = this.countryCallingCodes()[callingCode];\n\n        if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {\n          return this.metadata.countries['001'];\n        }\n      }\n    } // Deprecated.\n\n  }, {\n    key: \"countryCallingCode\",\n    value: function countryCallingCode() {\n      return this.numberingPlan.callingCode();\n    } // Deprecated.\n\n  }, {\n    key: \"IDDPrefix\",\n    value: function IDDPrefix() {\n      return this.numberingPlan.IDDPrefix();\n    } // Deprecated.\n\n  }, {\n    key: \"defaultIDDPrefix\",\n    value: function defaultIDDPrefix() {\n      return this.numberingPlan.defaultIDDPrefix();\n    } // Deprecated.\n\n  }, {\n    key: \"nationalNumberPattern\",\n    value: function nationalNumberPattern() {\n      return this.numberingPlan.nationalNumberPattern();\n    } // Deprecated.\n\n  }, {\n    key: \"possibleLengths\",\n    value: function possibleLengths() {\n      return this.numberingPlan.possibleLengths();\n    } // Deprecated.\n\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      return this.numberingPlan.formats();\n    } // Deprecated.\n\n  }, {\n    key: \"nationalPrefixForParsing\",\n    value: function nationalPrefixForParsing() {\n      return this.numberingPlan.nationalPrefixForParsing();\n    } // Deprecated.\n\n  }, {\n    key: \"nationalPrefixTransformRule\",\n    value: function nationalPrefixTransformRule() {\n      return this.numberingPlan.nationalPrefixTransformRule();\n    } // Deprecated.\n\n  }, {\n    key: \"leadingDigits\",\n    value: function leadingDigits() {\n      return this.numberingPlan.leadingDigits();\n    } // Deprecated.\n\n  }, {\n    key: \"hasTypes\",\n    value: function hasTypes() {\n      return this.numberingPlan.hasTypes();\n    } // Deprecated.\n\n  }, {\n    key: \"type\",\n    value: function type(_type) {\n      return this.numberingPlan.type(_type);\n    } // Deprecated.\n\n  }, {\n    key: \"ext\",\n    value: function ext() {\n      return this.numberingPlan.ext();\n    }\n  }, {\n    key: \"countryCallingCodes\",\n    value: function countryCallingCodes() {\n      if (this.v1) return this.metadata.country_phone_code_to_countries;\n      return this.metadata.country_calling_codes;\n    } // Deprecated.\n\n  }, {\n    key: \"chooseCountryByCountryCallingCode\",\n    value: function chooseCountryByCountryCallingCode(callingCode) {\n      return this.selectNumberingPlan(callingCode);\n    }\n  }, {\n    key: \"hasSelectedNumberingPlan\",\n    value: function hasSelectedNumberingPlan() {\n      return this.numberingPlan !== undefined;\n    }\n  }]);\n\n  return Metadata;\n}();\n\nexport { Metadata as default };\n\nvar NumberingPlan = /*#__PURE__*/function () {\n  function NumberingPlan(metadata, globalMetadataObject) {\n    _classCallCheck(this, NumberingPlan);\n\n    this.globalMetadataObject = globalMetadataObject;\n    this.metadata = metadata;\n    setVersion.call(this, globalMetadataObject.metadata);\n  }\n\n  _createClass(NumberingPlan, [{\n    key: \"callingCode\",\n    value: function callingCode() {\n      return this.metadata[0];\n    } // Formatting information for regions which share\n    // a country calling code is contained by only one region\n    // for performance reasons. For example, for NANPA region\n    // (\"North American Numbering Plan Administration\",\n    //  which includes USA, Canada, Cayman Islands, Bahamas, etc)\n    // it will be contained in the metadata for `US`.\n\n  }, {\n    key: \"getDefaultCountryMetadataForRegion\",\n    value: function getDefaultCountryMetadataForRegion() {\n      return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode());\n    } // Is always present.\n\n  }, {\n    key: \"IDDPrefix\",\n    value: function IDDPrefix() {\n      if (this.v1 || this.v2) return;\n      return this.metadata[1];\n    } // Is only present when a country supports multiple IDD prefixes.\n\n  }, {\n    key: \"defaultIDDPrefix\",\n    value: function defaultIDDPrefix() {\n      if (this.v1 || this.v2) return;\n      return this.metadata[12];\n    }\n  }, {\n    key: \"nationalNumberPattern\",\n    value: function nationalNumberPattern() {\n      if (this.v1 || this.v2) return this.metadata[1];\n      return this.metadata[2];\n    } // \"possible length\" data is always present in Google's metadata.\n\n  }, {\n    key: \"possibleLengths\",\n    value: function possibleLengths() {\n      if (this.v1) return;\n      return this.metadata[this.v2 ? 2 : 3];\n    }\n  }, {\n    key: \"_getFormats\",\n    value: function _getFormats(metadata) {\n      return metadata[this.v1 ? 2 : this.v2 ? 3 : 4];\n    } // For countries of the same region (e.g. NANPA)\n    // formats are all stored in the \"main\" country for that region.\n    // E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\n\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      var _this = this;\n\n      var formats = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];\n      return formats.map(function (_) {\n        return new Format(_, _this);\n      });\n    }\n  }, {\n    key: \"nationalPrefix\",\n    value: function nationalPrefix() {\n      return this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5];\n    }\n  }, {\n    key: \"_getNationalPrefixFormattingRule\",\n    value: function _getNationalPrefixFormattingRule(metadata) {\n      return metadata[this.v1 ? 4 : this.v2 ? 5 : 6];\n    } // For countries of the same region (e.g. NANPA)\n    // national prefix formatting rule is stored in the \"main\" country for that region.\n    // E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\n\n  }, {\n    key: \"nationalPrefixFormattingRule\",\n    value: function nationalPrefixFormattingRule() {\n      return this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion());\n    }\n  }, {\n    key: \"_nationalPrefixForParsing\",\n    value: function _nationalPrefixForParsing() {\n      return this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7];\n    }\n  }, {\n    key: \"nationalPrefixForParsing\",\n    value: function nationalPrefixForParsing() {\n      // If `national_prefix_for_parsing` is not set explicitly,\n      // then infer it from `national_prefix` (if any)\n      return this._nationalPrefixForParsing() || this.nationalPrefix();\n    }\n  }, {\n    key: \"nationalPrefixTransformRule\",\n    value: function nationalPrefixTransformRule() {\n      return this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8];\n    }\n  }, {\n    key: \"_getNationalPrefixIsOptionalWhenFormatting\",\n    value: function _getNationalPrefixIsOptionalWhenFormatting() {\n      return !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9];\n    } // For countries of the same region (e.g. NANPA)\n    // \"national prefix is optional when formatting\" flag is\n    // stored in the \"main\" country for that region.\n    // E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\n\n  }, {\n    key: \"nationalPrefixIsOptionalWhenFormattingInNationalFormat\",\n    value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {\n      return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion());\n    }\n  }, {\n    key: \"leadingDigits\",\n    value: function leadingDigits() {\n      return this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10];\n    }\n  }, {\n    key: \"types\",\n    value: function types() {\n      return this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11];\n    }\n  }, {\n    key: \"hasTypes\",\n    value: function hasTypes() {\n      // Versions 1.2.0 - 1.2.4: can be `[]`.\n\n      /* istanbul ignore next */\n      if (this.types() && this.types().length === 0) {\n        return false;\n      } // Versions <= 1.2.4: can be `undefined`.\n      // Version >= 1.2.5: can be `0`.\n\n\n      return !!this.types();\n    }\n  }, {\n    key: \"type\",\n    value: function type(_type2) {\n      if (this.hasTypes() && getType(this.types(), _type2)) {\n        return new Type(getType(this.types(), _type2), this);\n      }\n    }\n  }, {\n    key: \"ext\",\n    value: function ext() {\n      if (this.v1 || this.v2) return DEFAULT_EXT_PREFIX;\n      return this.metadata[13] || DEFAULT_EXT_PREFIX;\n    }\n  }]);\n\n  return NumberingPlan;\n}();\n\nvar Format = /*#__PURE__*/function () {\n  function Format(format, metadata) {\n    _classCallCheck(this, Format);\n\n    this._format = format;\n    this.metadata = metadata;\n  }\n\n  _createClass(Format, [{\n    key: \"pattern\",\n    value: function pattern() {\n      return this._format[0];\n    }\n  }, {\n    key: \"format\",\n    value: function format() {\n      return this._format[1];\n    }\n  }, {\n    key: \"leadingDigitsPatterns\",\n    value: function leadingDigitsPatterns() {\n      return this._format[2] || [];\n    }\n  }, {\n    key: \"nationalPrefixFormattingRule\",\n    value: function nationalPrefixFormattingRule() {\n      return this._format[3] || this.metadata.nationalPrefixFormattingRule();\n    }\n  }, {\n    key: \"nationalPrefixIsOptionalWhenFormattingInNationalFormat\",\n    value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {\n      return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat();\n    }\n  }, {\n    key: \"nationalPrefixIsMandatoryWhenFormattingInNationalFormat\",\n    value: function nationalPrefixIsMandatoryWhenFormattingInNationalFormat() {\n      // National prefix is omitted if there's no national prefix formatting rule\n      // set for this country, or when the national prefix formatting rule\n      // contains no national prefix itself, or when this rule is set but\n      // national prefix is optional for this phone number format\n      // (and it is not enforced explicitly)\n      return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat();\n    } // Checks whether national prefix formatting rule contains national prefix.\n\n  }, {\n    key: \"usesNationalPrefix\",\n    value: function usesNationalPrefix() {\n      return this.nationalPrefixFormattingRule() && // Check that national prefix formatting rule is not a \"dummy\" one.\n      !FIRST_GROUP_ONLY_PREFIX_PATTERN.test(this.nationalPrefixFormattingRule()) // In compressed metadata, `this.nationalPrefixFormattingRule()` is `0`\n      // when `national_prefix_formatting_rule` is not present.\n      // So, `true` or `false` are returned explicitly here, so that\n      // `0` number isn't returned.\n      ? true : false;\n    }\n  }, {\n    key: \"internationalFormat\",\n    value: function internationalFormat() {\n      return this._format[5] || this.format();\n    }\n  }]);\n\n  return Format;\n}();\n/**\r\n * A pattern that is used to determine if the national prefix formatting rule\r\n * has the first group only, i.e., does not start with the national prefix.\r\n * Note that the pattern explicitly allows for unbalanced parentheses.\r\n */\n\n\nvar FIRST_GROUP_ONLY_PREFIX_PATTERN = /^\\(?\\$1\\)?$/;\n\nvar Type = /*#__PURE__*/function () {\n  function Type(type, metadata) {\n    _classCallCheck(this, Type);\n\n    this.type = type;\n    this.metadata = metadata;\n  }\n\n  _createClass(Type, [{\n    key: \"pattern\",\n    value: function pattern() {\n      if (this.metadata.v1) return this.type;\n      return this.type[0];\n    }\n  }, {\n    key: \"possibleLengths\",\n    value: function possibleLengths() {\n      if (this.metadata.v1) return;\n      return this.type[1] || this.metadata.possibleLengths();\n    }\n  }]);\n\n  return Type;\n}();\n\nfunction getType(types, type) {\n  switch (type) {\n    case 'FIXED_LINE':\n      return types[0];\n\n    case 'MOBILE':\n      return types[1];\n\n    case 'TOLL_FREE':\n      return types[2];\n\n    case 'PREMIUM_RATE':\n      return types[3];\n\n    case 'PERSONAL_NUMBER':\n      return types[4];\n\n    case 'VOICEMAIL':\n      return types[5];\n\n    case 'UAN':\n      return types[6];\n\n    case 'PAGER':\n      return types[7];\n\n    case 'VOIP':\n      return types[8];\n\n    case 'SHARED_COST':\n      return types[9];\n  }\n}\n\nexport function validateMetadata(metadata) {\n  if (!metadata) {\n    throw new Error('[libphonenumber-js] `metadata` argument not passed. Check your arguments.');\n  } // `country_phone_code_to_countries` was renamed to\n  // `country_calling_codes` in `1.0.18`.\n\n\n  if (!is_object(metadata) || !is_object(metadata.countries)) {\n    throw new Error(\"[libphonenumber-js] `metadata` argument was passed but it's not a valid metadata. Must be an object having `.countries` child object property. Got \".concat(is_object(metadata) ? 'an object of shape: { ' + Object.keys(metadata).join(', ') + ' }' : 'a ' + type_of(metadata) + ': ' + metadata, \".\"));\n  }\n} // Babel transforms `typeof` into some \"branches\"\n// so istanbul will show this as \"branch not covered\".\n\n/* istanbul ignore next */\n\nvar is_object = function is_object(_) {\n  return _typeof(_) === 'object';\n}; // Babel transforms `typeof` into some \"branches\"\n// so istanbul will show this as \"branch not covered\".\n\n/* istanbul ignore next */\n\n\nvar type_of = function type_of(_) {\n  return _typeof(_);\n};\n/**\r\n * Returns extension prefix for a country.\r\n * @param  {string} country\r\n * @param  {object} metadata\r\n * @return {string?}\r\n * @example\r\n * // Returns \" ext. \"\r\n * getExtPrefix(\"US\")\r\n */\n\n\nexport function getExtPrefix(country, metadata) {\n  metadata = new Metadata(metadata);\n\n  if (metadata.hasCountry(country)) {\n    return metadata.country(country).ext();\n  }\n\n  return DEFAULT_EXT_PREFIX;\n}\n/**\r\n * Returns \"country calling code\" for a country.\r\n * Throws an error if the country doesn't exist or isn't supported by this library.\r\n * @param  {string} country\r\n * @param  {object} metadata\r\n * @return {string}\r\n * @example\r\n * // Returns \"44\"\r\n * getCountryCallingCode(\"GB\")\r\n */\n\nexport function getCountryCallingCode(country, metadata) {\n  metadata = new Metadata(metadata);\n\n  if (metadata.hasCountry(country)) {\n    return metadata.country(country).countryCallingCode();\n  }\n\n  throw new Error(\"Unknown country: \".concat(country));\n}\nexport function isSupportedCountry(country, metadata) {\n  // metadata = new Metadata(metadata)\n  // return metadata.hasCountry(country)\n  return metadata.countries[country] !== undefined;\n}\n\nfunction setVersion(metadata) {\n  var version = metadata.version;\n\n  if (typeof version === 'number') {\n    this.v1 = version === 1;\n    this.v2 = version === 2;\n    this.v3 = version === 3;\n    this.v4 = version === 4;\n  } else {\n    if (!version) {\n      this.v1 = true;\n    } else if (compare(version, V3) === -1) {\n      this.v2 = true;\n    } else if (compare(version, V4) === -1) {\n      this.v3 = true;\n    } else {\n      this.v4 = true;\n    }\n  }\n} // const ISO_COUNTRY_CODE = /^[A-Z]{2}$/\n// function isCountryCode(countryCode) {\n// \treturn ISO_COUNTRY_CODE.test(countryCodeOrCountryCallingCode)\n// }","map":{"version":3,"sources":["C:/Users/HP/Documents/code/Digital Switch/AAM-Templates/aam-volt/node_modules/libphonenumber-js/es6/metadata.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","compare","V2","V3","V4","DEFAULT_EXT_PREFIX","CALLING_CODE_REG_EXP","Metadata","metadata","validateMetadata","setVersion","call","value","getCountries","keys","countries","filter","_","getCountryMetadata","countryCode","nonGeographic","v1","v2","v3","nonGeographical","hasCountry","country","undefined","hasCallingCode","callingCode","getCountryCodesForCallingCode","countryCodes","countryCallingCodes","isNonGeographicCallingCode","selectNumberingPlan","test","Error","concat","numberingPlan","NumberingPlan","getNumberingPlanMetadata","getCountryCodeForCallingCode","countryCallingCode","IDDPrefix","defaultIDDPrefix","nationalNumberPattern","possibleLengths","formats","nationalPrefixForParsing","nationalPrefixTransformRule","leadingDigits","hasTypes","type","_type","ext","country_phone_code_to_countries","country_calling_codes","chooseCountryByCountryCallingCode","hasSelectedNumberingPlan","default","globalMetadataObject","getDefaultCountryMetadataForRegion","_getFormats","_this","map","Format","nationalPrefix","_getNationalPrefixFormattingRule","nationalPrefixFormattingRule","_nationalPrefixForParsing","_getNationalPrefixIsOptionalWhenFormatting","nationalPrefixIsOptionalWhenFormattingInNationalFormat","types","_type2","getType","Type","format","_format","pattern","leadingDigitsPatterns","nationalPrefixIsMandatoryWhenFormattingInNationalFormat","usesNationalPrefix","FIRST_GROUP_ONLY_PREFIX_PATTERN","internationalFormat","is_object","join","type_of","getExtPrefix","getCountryCallingCode","isSupportedCountry","version","v4"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport compare from './tools/semver-compare.js'; // Added \"possibleLengths\" and renamed\n// \"country_phone_code_to_countries\" to \"country_calling_codes\".\n\nvar V2 = '1.0.18'; // Added \"idd_prefix\" and \"default_idd_prefix\".\n\nvar V3 = '1.2.0'; // Moved `001` country code to \"nonGeographic\" section of metadata.\n\nvar V4 = '1.7.35';\nvar DEFAULT_EXT_PREFIX = ' ext. ';\nvar CALLING_CODE_REG_EXP = /^\\d+$/;\n/**\r\n * See: https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md\r\n */\n\nvar Metadata = /*#__PURE__*/function () {\n  function Metadata(metadata) {\n    _classCallCheck(this, Metadata);\n\n    validateMetadata(metadata);\n    this.metadata = metadata;\n    setVersion.call(this, metadata);\n  }\n\n  _createClass(Metadata, [{\n    key: \"getCountries\",\n    value: function getCountries() {\n      return Object.keys(this.metadata.countries).filter(function (_) {\n        return _ !== '001';\n      });\n    }\n  }, {\n    key: \"getCountryMetadata\",\n    value: function getCountryMetadata(countryCode) {\n      return this.metadata.countries[countryCode];\n    }\n  }, {\n    key: \"nonGeographic\",\n    value: function nonGeographic() {\n      if (this.v1 || this.v2 || this.v3) return; // `nonGeographical` was a typo.\n      // It's present in metadata generated from `1.7.35` to `1.7.37`.\n      // The test case could be found by searching for \"nonGeographical\".\n\n      return this.metadata.nonGeographic || this.metadata.nonGeographical;\n    }\n  }, {\n    key: \"hasCountry\",\n    value: function hasCountry(country) {\n      return this.getCountryMetadata(country) !== undefined;\n    }\n  }, {\n    key: \"hasCallingCode\",\n    value: function hasCallingCode(callingCode) {\n      if (this.getCountryCodesForCallingCode(callingCode)) {\n        return true;\n      }\n\n      if (this.nonGeographic()) {\n        if (this.nonGeographic()[callingCode]) {\n          return true;\n        }\n      } else {\n        // A hacky workaround for old custom metadata (generated before V4).\n        var countryCodes = this.countryCallingCodes()[callingCode];\n\n        if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {\n          return true;\n        }\n      }\n    }\n  }, {\n    key: \"isNonGeographicCallingCode\",\n    value: function isNonGeographicCallingCode(callingCode) {\n      if (this.nonGeographic()) {\n        return this.nonGeographic()[callingCode] ? true : false;\n      } else {\n        return this.getCountryCodesForCallingCode(callingCode) ? false : true;\n      }\n    } // Deprecated.\n\n  }, {\n    key: \"country\",\n    value: function country(countryCode) {\n      return this.selectNumberingPlan(countryCode);\n    }\n  }, {\n    key: \"selectNumberingPlan\",\n    value: function selectNumberingPlan(countryCode, callingCode) {\n      // Supports just passing `callingCode` as the first argument.\n      if (countryCode && CALLING_CODE_REG_EXP.test(countryCode)) {\n        callingCode = countryCode;\n        countryCode = null;\n      }\n\n      if (countryCode && countryCode !== '001') {\n        if (!this.hasCountry(countryCode)) {\n          throw new Error(\"Unknown country: \".concat(countryCode));\n        }\n\n        this.numberingPlan = new NumberingPlan(this.getCountryMetadata(countryCode), this);\n      } else if (callingCode) {\n        if (!this.hasCallingCode(callingCode)) {\n          throw new Error(\"Unknown calling code: \".concat(callingCode));\n        }\n\n        this.numberingPlan = new NumberingPlan(this.getNumberingPlanMetadata(callingCode), this);\n      } else {\n        this.numberingPlan = undefined;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getCountryCodesForCallingCode\",\n    value: function getCountryCodesForCallingCode(callingCode) {\n      var countryCodes = this.countryCallingCodes()[callingCode];\n\n      if (countryCodes) {\n        // Metadata before V4 included \"non-geographic entity\" calling codes\n        // inside `country_calling_codes` (for example, `\"881\":[\"001\"]`).\n        // Now the semantics of `country_calling_codes` has changed:\n        // it's specifically for \"countries\" now.\n        // Older versions of custom metadata will simply skip parsing\n        // \"non-geographic entity\" phone numbers with new versions\n        // of this library: it's not considered a bug,\n        // because such numbers are extremely rare,\n        // and developers extremely rarely use custom metadata.\n        if (countryCodes.length === 1 && countryCodes[0].length === 3) {\n          return;\n        }\n\n        return countryCodes;\n      }\n    }\n  }, {\n    key: \"getCountryCodeForCallingCode\",\n    value: function getCountryCodeForCallingCode(callingCode) {\n      var countryCodes = this.getCountryCodesForCallingCode(callingCode);\n\n      if (countryCodes) {\n        return countryCodes[0];\n      }\n    }\n  }, {\n    key: \"getNumberingPlanMetadata\",\n    value: function getNumberingPlanMetadata(callingCode) {\n      var countryCode = this.getCountryCodeForCallingCode(callingCode);\n\n      if (countryCode) {\n        return this.getCountryMetadata(countryCode);\n      }\n\n      if (this.nonGeographic()) {\n        var metadata = this.nonGeographic()[callingCode];\n\n        if (metadata) {\n          return metadata;\n        }\n      } else {\n        // A hacky workaround for old custom metadata (generated before V4).\n        // In that metadata, there was no concept of \"non-geographic\" metadata\n        // so metadata for `001` country code was stored along with other countries.\n        // The test case can be found by searching for:\n        // \"should work around `nonGeographic` metadata not existing\".\n        var countryCodes = this.countryCallingCodes()[callingCode];\n\n        if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {\n          return this.metadata.countries['001'];\n        }\n      }\n    } // Deprecated.\n\n  }, {\n    key: \"countryCallingCode\",\n    value: function countryCallingCode() {\n      return this.numberingPlan.callingCode();\n    } // Deprecated.\n\n  }, {\n    key: \"IDDPrefix\",\n    value: function IDDPrefix() {\n      return this.numberingPlan.IDDPrefix();\n    } // Deprecated.\n\n  }, {\n    key: \"defaultIDDPrefix\",\n    value: function defaultIDDPrefix() {\n      return this.numberingPlan.defaultIDDPrefix();\n    } // Deprecated.\n\n  }, {\n    key: \"nationalNumberPattern\",\n    value: function nationalNumberPattern() {\n      return this.numberingPlan.nationalNumberPattern();\n    } // Deprecated.\n\n  }, {\n    key: \"possibleLengths\",\n    value: function possibleLengths() {\n      return this.numberingPlan.possibleLengths();\n    } // Deprecated.\n\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      return this.numberingPlan.formats();\n    } // Deprecated.\n\n  }, {\n    key: \"nationalPrefixForParsing\",\n    value: function nationalPrefixForParsing() {\n      return this.numberingPlan.nationalPrefixForParsing();\n    } // Deprecated.\n\n  }, {\n    key: \"nationalPrefixTransformRule\",\n    value: function nationalPrefixTransformRule() {\n      return this.numberingPlan.nationalPrefixTransformRule();\n    } // Deprecated.\n\n  }, {\n    key: \"leadingDigits\",\n    value: function leadingDigits() {\n      return this.numberingPlan.leadingDigits();\n    } // Deprecated.\n\n  }, {\n    key: \"hasTypes\",\n    value: function hasTypes() {\n      return this.numberingPlan.hasTypes();\n    } // Deprecated.\n\n  }, {\n    key: \"type\",\n    value: function type(_type) {\n      return this.numberingPlan.type(_type);\n    } // Deprecated.\n\n  }, {\n    key: \"ext\",\n    value: function ext() {\n      return this.numberingPlan.ext();\n    }\n  }, {\n    key: \"countryCallingCodes\",\n    value: function countryCallingCodes() {\n      if (this.v1) return this.metadata.country_phone_code_to_countries;\n      return this.metadata.country_calling_codes;\n    } // Deprecated.\n\n  }, {\n    key: \"chooseCountryByCountryCallingCode\",\n    value: function chooseCountryByCountryCallingCode(callingCode) {\n      return this.selectNumberingPlan(callingCode);\n    }\n  }, {\n    key: \"hasSelectedNumberingPlan\",\n    value: function hasSelectedNumberingPlan() {\n      return this.numberingPlan !== undefined;\n    }\n  }]);\n\n  return Metadata;\n}();\n\nexport { Metadata as default };\n\nvar NumberingPlan = /*#__PURE__*/function () {\n  function NumberingPlan(metadata, globalMetadataObject) {\n    _classCallCheck(this, NumberingPlan);\n\n    this.globalMetadataObject = globalMetadataObject;\n    this.metadata = metadata;\n    setVersion.call(this, globalMetadataObject.metadata);\n  }\n\n  _createClass(NumberingPlan, [{\n    key: \"callingCode\",\n    value: function callingCode() {\n      return this.metadata[0];\n    } // Formatting information for regions which share\n    // a country calling code is contained by only one region\n    // for performance reasons. For example, for NANPA region\n    // (\"North American Numbering Plan Administration\",\n    //  which includes USA, Canada, Cayman Islands, Bahamas, etc)\n    // it will be contained in the metadata for `US`.\n\n  }, {\n    key: \"getDefaultCountryMetadataForRegion\",\n    value: function getDefaultCountryMetadataForRegion() {\n      return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode());\n    } // Is always present.\n\n  }, {\n    key: \"IDDPrefix\",\n    value: function IDDPrefix() {\n      if (this.v1 || this.v2) return;\n      return this.metadata[1];\n    } // Is only present when a country supports multiple IDD prefixes.\n\n  }, {\n    key: \"defaultIDDPrefix\",\n    value: function defaultIDDPrefix() {\n      if (this.v1 || this.v2) return;\n      return this.metadata[12];\n    }\n  }, {\n    key: \"nationalNumberPattern\",\n    value: function nationalNumberPattern() {\n      if (this.v1 || this.v2) return this.metadata[1];\n      return this.metadata[2];\n    } // \"possible length\" data is always present in Google's metadata.\n\n  }, {\n    key: \"possibleLengths\",\n    value: function possibleLengths() {\n      if (this.v1) return;\n      return this.metadata[this.v2 ? 2 : 3];\n    }\n  }, {\n    key: \"_getFormats\",\n    value: function _getFormats(metadata) {\n      return metadata[this.v1 ? 2 : this.v2 ? 3 : 4];\n    } // For countries of the same region (e.g. NANPA)\n    // formats are all stored in the \"main\" country for that region.\n    // E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\n\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      var _this = this;\n\n      var formats = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];\n      return formats.map(function (_) {\n        return new Format(_, _this);\n      });\n    }\n  }, {\n    key: \"nationalPrefix\",\n    value: function nationalPrefix() {\n      return this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5];\n    }\n  }, {\n    key: \"_getNationalPrefixFormattingRule\",\n    value: function _getNationalPrefixFormattingRule(metadata) {\n      return metadata[this.v1 ? 4 : this.v2 ? 5 : 6];\n    } // For countries of the same region (e.g. NANPA)\n    // national prefix formatting rule is stored in the \"main\" country for that region.\n    // E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\n\n  }, {\n    key: \"nationalPrefixFormattingRule\",\n    value: function nationalPrefixFormattingRule() {\n      return this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion());\n    }\n  }, {\n    key: \"_nationalPrefixForParsing\",\n    value: function _nationalPrefixForParsing() {\n      return this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7];\n    }\n  }, {\n    key: \"nationalPrefixForParsing\",\n    value: function nationalPrefixForParsing() {\n      // If `national_prefix_for_parsing` is not set explicitly,\n      // then infer it from `national_prefix` (if any)\n      return this._nationalPrefixForParsing() || this.nationalPrefix();\n    }\n  }, {\n    key: \"nationalPrefixTransformRule\",\n    value: function nationalPrefixTransformRule() {\n      return this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8];\n    }\n  }, {\n    key: \"_getNationalPrefixIsOptionalWhenFormatting\",\n    value: function _getNationalPrefixIsOptionalWhenFormatting() {\n      return !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9];\n    } // For countries of the same region (e.g. NANPA)\n    // \"national prefix is optional when formatting\" flag is\n    // stored in the \"main\" country for that region.\n    // E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\n\n  }, {\n    key: \"nationalPrefixIsOptionalWhenFormattingInNationalFormat\",\n    value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {\n      return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion());\n    }\n  }, {\n    key: \"leadingDigits\",\n    value: function leadingDigits() {\n      return this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10];\n    }\n  }, {\n    key: \"types\",\n    value: function types() {\n      return this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11];\n    }\n  }, {\n    key: \"hasTypes\",\n    value: function hasTypes() {\n      // Versions 1.2.0 - 1.2.4: can be `[]`.\n\n      /* istanbul ignore next */\n      if (this.types() && this.types().length === 0) {\n        return false;\n      } // Versions <= 1.2.4: can be `undefined`.\n      // Version >= 1.2.5: can be `0`.\n\n\n      return !!this.types();\n    }\n  }, {\n    key: \"type\",\n    value: function type(_type2) {\n      if (this.hasTypes() && getType(this.types(), _type2)) {\n        return new Type(getType(this.types(), _type2), this);\n      }\n    }\n  }, {\n    key: \"ext\",\n    value: function ext() {\n      if (this.v1 || this.v2) return DEFAULT_EXT_PREFIX;\n      return this.metadata[13] || DEFAULT_EXT_PREFIX;\n    }\n  }]);\n\n  return NumberingPlan;\n}();\n\nvar Format = /*#__PURE__*/function () {\n  function Format(format, metadata) {\n    _classCallCheck(this, Format);\n\n    this._format = format;\n    this.metadata = metadata;\n  }\n\n  _createClass(Format, [{\n    key: \"pattern\",\n    value: function pattern() {\n      return this._format[0];\n    }\n  }, {\n    key: \"format\",\n    value: function format() {\n      return this._format[1];\n    }\n  }, {\n    key: \"leadingDigitsPatterns\",\n    value: function leadingDigitsPatterns() {\n      return this._format[2] || [];\n    }\n  }, {\n    key: \"nationalPrefixFormattingRule\",\n    value: function nationalPrefixFormattingRule() {\n      return this._format[3] || this.metadata.nationalPrefixFormattingRule();\n    }\n  }, {\n    key: \"nationalPrefixIsOptionalWhenFormattingInNationalFormat\",\n    value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {\n      return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat();\n    }\n  }, {\n    key: \"nationalPrefixIsMandatoryWhenFormattingInNationalFormat\",\n    value: function nationalPrefixIsMandatoryWhenFormattingInNationalFormat() {\n      // National prefix is omitted if there's no national prefix formatting rule\n      // set for this country, or when the national prefix formatting rule\n      // contains no national prefix itself, or when this rule is set but\n      // national prefix is optional for this phone number format\n      // (and it is not enforced explicitly)\n      return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat();\n    } // Checks whether national prefix formatting rule contains national prefix.\n\n  }, {\n    key: \"usesNationalPrefix\",\n    value: function usesNationalPrefix() {\n      return this.nationalPrefixFormattingRule() && // Check that national prefix formatting rule is not a \"dummy\" one.\n      !FIRST_GROUP_ONLY_PREFIX_PATTERN.test(this.nationalPrefixFormattingRule()) // In compressed metadata, `this.nationalPrefixFormattingRule()` is `0`\n      // when `national_prefix_formatting_rule` is not present.\n      // So, `true` or `false` are returned explicitly here, so that\n      // `0` number isn't returned.\n      ? true : false;\n    }\n  }, {\n    key: \"internationalFormat\",\n    value: function internationalFormat() {\n      return this._format[5] || this.format();\n    }\n  }]);\n\n  return Format;\n}();\n/**\r\n * A pattern that is used to determine if the national prefix formatting rule\r\n * has the first group only, i.e., does not start with the national prefix.\r\n * Note that the pattern explicitly allows for unbalanced parentheses.\r\n */\n\n\nvar FIRST_GROUP_ONLY_PREFIX_PATTERN = /^\\(?\\$1\\)?$/;\n\nvar Type = /*#__PURE__*/function () {\n  function Type(type, metadata) {\n    _classCallCheck(this, Type);\n\n    this.type = type;\n    this.metadata = metadata;\n  }\n\n  _createClass(Type, [{\n    key: \"pattern\",\n    value: function pattern() {\n      if (this.metadata.v1) return this.type;\n      return this.type[0];\n    }\n  }, {\n    key: \"possibleLengths\",\n    value: function possibleLengths() {\n      if (this.metadata.v1) return;\n      return this.type[1] || this.metadata.possibleLengths();\n    }\n  }]);\n\n  return Type;\n}();\n\nfunction getType(types, type) {\n  switch (type) {\n    case 'FIXED_LINE':\n      return types[0];\n\n    case 'MOBILE':\n      return types[1];\n\n    case 'TOLL_FREE':\n      return types[2];\n\n    case 'PREMIUM_RATE':\n      return types[3];\n\n    case 'PERSONAL_NUMBER':\n      return types[4];\n\n    case 'VOICEMAIL':\n      return types[5];\n\n    case 'UAN':\n      return types[6];\n\n    case 'PAGER':\n      return types[7];\n\n    case 'VOIP':\n      return types[8];\n\n    case 'SHARED_COST':\n      return types[9];\n  }\n}\n\nexport function validateMetadata(metadata) {\n  if (!metadata) {\n    throw new Error('[libphonenumber-js] `metadata` argument not passed. Check your arguments.');\n  } // `country_phone_code_to_countries` was renamed to\n  // `country_calling_codes` in `1.0.18`.\n\n\n  if (!is_object(metadata) || !is_object(metadata.countries)) {\n    throw new Error(\"[libphonenumber-js] `metadata` argument was passed but it's not a valid metadata. Must be an object having `.countries` child object property. Got \".concat(is_object(metadata) ? 'an object of shape: { ' + Object.keys(metadata).join(', ') + ' }' : 'a ' + type_of(metadata) + ': ' + metadata, \".\"));\n  }\n} // Babel transforms `typeof` into some \"branches\"\n// so istanbul will show this as \"branch not covered\".\n\n/* istanbul ignore next */\n\nvar is_object = function is_object(_) {\n  return _typeof(_) === 'object';\n}; // Babel transforms `typeof` into some \"branches\"\n// so istanbul will show this as \"branch not covered\".\n\n/* istanbul ignore next */\n\n\nvar type_of = function type_of(_) {\n  return _typeof(_);\n};\n/**\r\n * Returns extension prefix for a country.\r\n * @param  {string} country\r\n * @param  {object} metadata\r\n * @return {string?}\r\n * @example\r\n * // Returns \" ext. \"\r\n * getExtPrefix(\"US\")\r\n */\n\n\nexport function getExtPrefix(country, metadata) {\n  metadata = new Metadata(metadata);\n\n  if (metadata.hasCountry(country)) {\n    return metadata.country(country).ext();\n  }\n\n  return DEFAULT_EXT_PREFIX;\n}\n/**\r\n * Returns \"country calling code\" for a country.\r\n * Throws an error if the country doesn't exist or isn't supported by this library.\r\n * @param  {string} country\r\n * @param  {object} metadata\r\n * @return {string}\r\n * @example\r\n * // Returns \"44\"\r\n * getCountryCallingCode(\"GB\")\r\n */\n\nexport function getCountryCallingCode(country, metadata) {\n  metadata = new Metadata(metadata);\n\n  if (metadata.hasCountry(country)) {\n    return metadata.country(country).countryCallingCode();\n  }\n\n  throw new Error(\"Unknown country: \".concat(country));\n}\nexport function isSupportedCountry(country, metadata) {\n  // metadata = new Metadata(metadata)\n  // return metadata.hasCountry(country)\n  return metadata.countries[country] !== undefined;\n}\n\nfunction setVersion(metadata) {\n  var version = metadata.version;\n\n  if (typeof version === 'number') {\n    this.v1 = version === 1;\n    this.v2 = version === 2;\n    this.v3 = version === 3;\n    this.v4 = version === 4;\n  } else {\n    if (!version) {\n      this.v1 = true;\n    } else if (compare(version, V3) === -1) {\n      this.v2 = true;\n    } else if (compare(version, V4) === -1) {\n      this.v3 = true;\n    } else {\n      this.v4 = true;\n    }\n  }\n} // const ISO_COUNTRY_CODE = /^[A-Z]{2}$/\n// function isCountryCode(countryCode) {\n// \treturn ISO_COUNTRY_CODE.test(countryCodeOrCountryCallingCode)\n// }\n//# sourceMappingURL=metadata.js.map"]},"metadata":{},"sourceType":"module"}