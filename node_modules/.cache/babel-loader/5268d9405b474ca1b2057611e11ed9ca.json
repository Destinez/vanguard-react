{"ast":null,"code":"// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of December 31th, 2018.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\nimport { VALID_DIGITS, PLUS_CHARS, MIN_LENGTH_FOR_NSN, MAX_LENGTH_FOR_NSN } from './constants.js';\nimport ParseError from './ParseError.js';\nimport Metadata from './metadata.js';\nimport isViablePhoneNumber, { isViablePhoneNumberStart } from './helpers/isViablePhoneNumber.js';\nimport extractExtension from './helpers/extension/extractExtension.js';\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber.js';\nimport getCountryCallingCode from './getCountryCallingCode.js';\nimport { isPossibleNumber } from './isPossibleNumber_.js';\nimport { parseRFC3966 } from './helpers/RFC3966.js';\nimport PhoneNumber from './PhoneNumber.js';\nimport matchesEntirely from './helpers/matchesEntirely.js';\nimport extractCountryCallingCode from './helpers/extractCountryCallingCode.js';\nimport extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js';\nimport extractNationalNumber from './helpers/extractNationalNumber.js';\nimport stripIddPrefix from './helpers/stripIddPrefix.js';\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode.js'; // We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\n\nvar MAX_INPUT_STRING_LENGTH = 250; // This consists of the plus symbol, digits, and arabic-indic digits.\n\nvar PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']'); // Regular expression of trailing characters that we want to remove.\n// A trailing `#` is sometimes used when writing phone numbers with extensions in US.\n// Example: \"+1 (645) 123 1234-910#\" number has extension \"910\".\n\nvar AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + '#' + ']+$');\nvar USE_NON_GEOGRAPHIC_COUNTRY_CODE = false; // Examples:\n//\n// ```js\n// parse('8 (800) 555-35-35', 'RU')\n// parse('8 (800) 555-35-35', 'RU', metadata)\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n// parse('+7 800 555 35 35')\n// parse('+7 800 555 35 35', metadata)\n// ```\n//\n\nexport default function parse(text, options, metadata) {\n  // If assigning the `{}` default value is moved to the arguments above,\n  // code coverage would decrease for some weird reason.\n  options = options || {};\n  metadata = new Metadata(metadata); // Validate `defaultCountry`.\n\n  if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\n    if (options.v2) {\n      throw new ParseError('INVALID_COUNTRY');\n    }\n\n    throw new Error(\"Unknown country: \".concat(options.defaultCountry));\n  } // Parse the phone number.\n\n\n  var _parseInput = parseInput(text, options.v2, options.extract),\n      formattedPhoneNumber = _parseInput.number,\n      ext = _parseInput.ext,\n      error = _parseInput.error; // If the phone number is not viable then return nothing.\n\n\n  if (!formattedPhoneNumber) {\n    if (options.v2) {\n      if (error === 'TOO_SHORT') {\n        throw new ParseError('TOO_SHORT');\n      }\n\n      throw new ParseError('NOT_A_NUMBER');\n    }\n\n    return {};\n  }\n\n  var _parsePhoneNumber = parsePhoneNumber(formattedPhoneNumber, options.defaultCountry, options.defaultCallingCode, metadata),\n      country = _parsePhoneNumber.country,\n      nationalNumber = _parsePhoneNumber.nationalNumber,\n      countryCallingCode = _parsePhoneNumber.countryCallingCode,\n      carrierCode = _parsePhoneNumber.carrierCode;\n\n  if (!metadata.hasSelectedNumberingPlan()) {\n    if (options.v2) {\n      throw new ParseError('INVALID_COUNTRY');\n    }\n\n    return {};\n  } // Validate national (significant) number length.\n\n\n  if (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\n    // Won't throw here because the regexp already demands length > 1.\n\n    /* istanbul ignore if */\n    if (options.v2) {\n      throw new ParseError('TOO_SHORT');\n    } // Google's demo just throws an error in this case.\n\n\n    return {};\n  } // Validate national (significant) number length.\n  //\n  // A sidenote:\n  //\n  // They say that sometimes national (significant) numbers\n  // can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n  // https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n  // Such numbers will just be discarded.\n  //\n\n\n  if (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\n    if (options.v2) {\n      throw new ParseError('TOO_LONG');\n    } // Google's demo just throws an error in this case.\n\n\n    return {};\n  }\n\n  if (options.v2) {\n    var phoneNumber = new PhoneNumber(countryCallingCode, nationalNumber, metadata.metadata);\n\n    if (country) {\n      phoneNumber.country = country;\n    }\n\n    if (carrierCode) {\n      phoneNumber.carrierCode = carrierCode;\n    }\n\n    if (ext) {\n      phoneNumber.ext = ext;\n    }\n\n    return phoneNumber;\n  } // Check if national phone number pattern matches the number.\n  // National number pattern is different for each country,\n  // even for those ones which are part of the \"NANPA\" group.\n\n\n  var valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ? matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) : false;\n\n  if (!options.extended) {\n    return valid ? result(country, nationalNumber, ext) : {};\n  } // isInternational: countryCallingCode !== undefined\n\n\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    carrierCode: carrierCode,\n    valid: valid,\n    possible: valid ? true : options.extended === true && metadata.possibleLengths() && isPossibleNumber(nationalNumber, metadata) ? true : false,\n    phone: nationalNumber,\n    ext: ext\n  };\n}\n/**\r\n * Extracts a formatted phone number from text.\r\n * Doesn't guarantee that the extracted phone number\r\n * is a valid phone number (for example, doesn't validate its length).\r\n * @param  {string} text\r\n * @param  {boolean} [extract] — If `false`, then will parse the entire `text` as a phone number.\r\n * @param  {boolean} [throwOnError] — By default, it won't throw if the text is too long.\r\n * @return {string}\r\n * @example\r\n * // Returns \"(213) 373-4253\".\r\n * extractFormattedPhoneNumber(\"Call (213) 373-4253 for assistance.\")\r\n */\n\nfunction extractFormattedPhoneNumber(text, extract, throwOnError) {\n  if (!text) {\n    return;\n  }\n\n  if (text.length > MAX_INPUT_STRING_LENGTH) {\n    if (throwOnError) {\n      throw new ParseError('TOO_LONG');\n    }\n\n    return;\n  }\n\n  if (extract === false) {\n    return text;\n  } // Attempt to extract a possible number from the string passed in\n\n\n  var startsAt = text.search(PHONE_NUMBER_START_PATTERN);\n\n  if (startsAt < 0) {\n    return;\n  }\n\n  return text // Trim everything to the left of the phone number\n  .slice(startsAt) // Remove trailing non-numerical characters\n  .replace(AFTER_PHONE_NUMBER_END_PATTERN, '');\n}\n/**\r\n * @param  {string} text - Input.\r\n * @param  {boolean} v2 - Legacy API functions don't pass `v2: true` flag.\r\n * @param  {boolean} [extract] - Whether to extract a phone number from `text`, or attempt to parse the entire text as a phone number.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\n\n\nfunction parseInput(text, v2, extract) {\n  // Parse RFC 3966 phone number URI.\n  if (text && text.indexOf('tel:') === 0) {\n    return parseRFC3966(text);\n  }\n\n  var number = extractFormattedPhoneNumber(text, extract, v2); // If the phone number is not viable, then abort.\n\n  if (!number) {\n    return {};\n  }\n\n  if (!isViablePhoneNumber(number)) {\n    if (isViablePhoneNumberStart(number)) {\n      return {\n        error: 'TOO_SHORT'\n      };\n    }\n\n    return {};\n  } // Attempt to parse extension first, since it doesn't require region-specific\n  // data and we want to have the non-normalised number here.\n\n\n  var withExtensionStripped = extractExtension(number);\n\n  if (withExtensionStripped.ext) {\n    return withExtensionStripped;\n  }\n\n  return {\n    number: number\n  };\n}\n/**\r\n * Creates `parse()` result object.\r\n */\n\n\nfunction result(country, nationalNumber, ext) {\n  var result = {\n    country: country,\n    phone: nationalNumber\n  };\n\n  if (ext) {\n    result.ext = ext;\n  }\n\n  return result;\n}\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber — Example: \"(213) 373-4253\".\r\n * @param {string} [defaultCountry]\r\n * @param {string} [defaultCallingCode]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\n\n\nfunction parsePhoneNumber(formattedPhoneNumber, defaultCountry, defaultCallingCode, metadata) {\n  // Extract calling code from phone number.\n  var _extractCountryCallin = extractCountryCallingCode(parseIncompletePhoneNumber(formattedPhoneNumber), defaultCountry, defaultCallingCode, metadata.metadata),\n      countryCallingCode = _extractCountryCallin.countryCallingCode,\n      number = _extractCountryCallin.number; // Choose a country by `countryCallingCode`.\n\n\n  var country;\n\n  if (countryCallingCode) {\n    metadata.selectNumberingPlan(countryCallingCode);\n  } // If `formattedPhoneNumber` is in \"national\" format\n  // then `number` is defined and `countryCallingCode` isn't.\n  else if (number && (defaultCountry || defaultCallingCode)) {\n    metadata.selectNumberingPlan(defaultCountry, defaultCallingCode);\n\n    if (defaultCountry) {\n      country = defaultCountry;\n    } else {\n      /* istanbul ignore if */\n      if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n        if (metadata.isNonGeographicCallingCode(defaultCallingCode)) {\n          country = '001';\n        }\n      }\n    }\n\n    countryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata);\n  } else return {};\n\n  if (!number) {\n    return {\n      countryCallingCode: countryCallingCode\n    };\n  }\n\n  var _extractNationalNumbe = extractNationalNumber(parseIncompletePhoneNumber(number), metadata),\n      nationalNumber = _extractNationalNumbe.nationalNumber,\n      carrierCode = _extractNationalNumbe.carrierCode; // Sometimes there are several countries\n  // corresponding to the same country phone code\n  // (e.g. NANPA countries all having `1` country phone code).\n  // Therefore, to reliably determine the exact country,\n  // national (significant) number should have been parsed first.\n  //\n  // When `metadata.json` is generated, all \"ambiguous\" country phone codes\n  // get their countries populated with the full set of\n  // \"phone number type\" regular expressions.\n  //\n\n\n  var exactCountry = getCountryByCallingCode(countryCallingCode, nationalNumber, metadata);\n\n  if (exactCountry) {\n    country = exactCountry;\n    /* istanbul ignore if */\n\n    if (exactCountry === '001') {// Can't happen with `USE_NON_GEOGRAPHIC_COUNTRY_CODE` being `false`.\n      // If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` is set to `true` for some reason,\n      // then remove the \"istanbul ignore if\".\n    } else {\n      metadata.country(country);\n    }\n  }\n\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    nationalNumber: nationalNumber,\n    carrierCode: carrierCode\n  };\n}","map":{"version":3,"sources":["C:/Users/HP/Documents/code/Digital Switch/AAM-Templates/aam-volt/node_modules/libphonenumber-js/es6/parse_.js"],"names":["VALID_DIGITS","PLUS_CHARS","MIN_LENGTH_FOR_NSN","MAX_LENGTH_FOR_NSN","ParseError","Metadata","isViablePhoneNumber","isViablePhoneNumberStart","extractExtension","parseIncompletePhoneNumber","getCountryCallingCode","isPossibleNumber","parseRFC3966","PhoneNumber","matchesEntirely","extractCountryCallingCode","extractCountryCallingCodeFromInternationalNumberWithoutPlusSign","extractNationalNumber","stripIddPrefix","getCountryByCallingCode","MAX_INPUT_STRING_LENGTH","PHONE_NUMBER_START_PATTERN","RegExp","AFTER_PHONE_NUMBER_END_PATTERN","USE_NON_GEOGRAPHIC_COUNTRY_CODE","parse","text","options","metadata","defaultCountry","hasCountry","v2","Error","concat","_parseInput","parseInput","extract","formattedPhoneNumber","number","ext","error","_parsePhoneNumber","parsePhoneNumber","defaultCallingCode","country","nationalNumber","countryCallingCode","carrierCode","hasSelectedNumberingPlan","length","phoneNumber","valid","extended","nationalNumberPattern","result","possible","possibleLengths","phone","extractFormattedPhoneNumber","throwOnError","startsAt","search","slice","replace","indexOf","withExtensionStripped","_extractCountryCallin","selectNumberingPlan","isNonGeographicCallingCode","_extractNationalNumbe","exactCountry"],"mappings":"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","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of December 31th, 2018.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\nimport { VALID_DIGITS, PLUS_CHARS, MIN_LENGTH_FOR_NSN, MAX_LENGTH_FOR_NSN } from './constants.js';\nimport ParseError from './ParseError.js';\nimport Metadata from './metadata.js';\nimport isViablePhoneNumber, { isViablePhoneNumberStart } from './helpers/isViablePhoneNumber.js';\nimport extractExtension from './helpers/extension/extractExtension.js';\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber.js';\nimport getCountryCallingCode from './getCountryCallingCode.js';\nimport { isPossibleNumber } from './isPossibleNumber_.js';\nimport { parseRFC3966 } from './helpers/RFC3966.js';\nimport PhoneNumber from './PhoneNumber.js';\nimport matchesEntirely from './helpers/matchesEntirely.js';\nimport extractCountryCallingCode from './helpers/extractCountryCallingCode.js';\nimport extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js';\nimport extractNationalNumber from './helpers/extractNationalNumber.js';\nimport stripIddPrefix from './helpers/stripIddPrefix.js';\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode.js'; // We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\n\nvar MAX_INPUT_STRING_LENGTH = 250; // This consists of the plus symbol, digits, and arabic-indic digits.\n\nvar PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']'); // Regular expression of trailing characters that we want to remove.\n// A trailing `#` is sometimes used when writing phone numbers with extensions in US.\n// Example: \"+1 (645) 123 1234-910#\" number has extension \"910\".\n\nvar AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + '#' + ']+$');\nvar USE_NON_GEOGRAPHIC_COUNTRY_CODE = false; // Examples:\n//\n// ```js\n// parse('8 (800) 555-35-35', 'RU')\n// parse('8 (800) 555-35-35', 'RU', metadata)\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n// parse('+7 800 555 35 35')\n// parse('+7 800 555 35 35', metadata)\n// ```\n//\n\nexport default function parse(text, options, metadata) {\n  // If assigning the `{}` default value is moved to the arguments above,\n  // code coverage would decrease for some weird reason.\n  options = options || {};\n  metadata = new Metadata(metadata); // Validate `defaultCountry`.\n\n  if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\n    if (options.v2) {\n      throw new ParseError('INVALID_COUNTRY');\n    }\n\n    throw new Error(\"Unknown country: \".concat(options.defaultCountry));\n  } // Parse the phone number.\n\n\n  var _parseInput = parseInput(text, options.v2, options.extract),\n      formattedPhoneNumber = _parseInput.number,\n      ext = _parseInput.ext,\n      error = _parseInput.error; // If the phone number is not viable then return nothing.\n\n\n  if (!formattedPhoneNumber) {\n    if (options.v2) {\n      if (error === 'TOO_SHORT') {\n        throw new ParseError('TOO_SHORT');\n      }\n\n      throw new ParseError('NOT_A_NUMBER');\n    }\n\n    return {};\n  }\n\n  var _parsePhoneNumber = parsePhoneNumber(formattedPhoneNumber, options.defaultCountry, options.defaultCallingCode, metadata),\n      country = _parsePhoneNumber.country,\n      nationalNumber = _parsePhoneNumber.nationalNumber,\n      countryCallingCode = _parsePhoneNumber.countryCallingCode,\n      carrierCode = _parsePhoneNumber.carrierCode;\n\n  if (!metadata.hasSelectedNumberingPlan()) {\n    if (options.v2) {\n      throw new ParseError('INVALID_COUNTRY');\n    }\n\n    return {};\n  } // Validate national (significant) number length.\n\n\n  if (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\n    // Won't throw here because the regexp already demands length > 1.\n\n    /* istanbul ignore if */\n    if (options.v2) {\n      throw new ParseError('TOO_SHORT');\n    } // Google's demo just throws an error in this case.\n\n\n    return {};\n  } // Validate national (significant) number length.\n  //\n  // A sidenote:\n  //\n  // They say that sometimes national (significant) numbers\n  // can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n  // https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n  // Such numbers will just be discarded.\n  //\n\n\n  if (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\n    if (options.v2) {\n      throw new ParseError('TOO_LONG');\n    } // Google's demo just throws an error in this case.\n\n\n    return {};\n  }\n\n  if (options.v2) {\n    var phoneNumber = new PhoneNumber(countryCallingCode, nationalNumber, metadata.metadata);\n\n    if (country) {\n      phoneNumber.country = country;\n    }\n\n    if (carrierCode) {\n      phoneNumber.carrierCode = carrierCode;\n    }\n\n    if (ext) {\n      phoneNumber.ext = ext;\n    }\n\n    return phoneNumber;\n  } // Check if national phone number pattern matches the number.\n  // National number pattern is different for each country,\n  // even for those ones which are part of the \"NANPA\" group.\n\n\n  var valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ? matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) : false;\n\n  if (!options.extended) {\n    return valid ? result(country, nationalNumber, ext) : {};\n  } // isInternational: countryCallingCode !== undefined\n\n\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    carrierCode: carrierCode,\n    valid: valid,\n    possible: valid ? true : options.extended === true && metadata.possibleLengths() && isPossibleNumber(nationalNumber, metadata) ? true : false,\n    phone: nationalNumber,\n    ext: ext\n  };\n}\n/**\r\n * Extracts a formatted phone number from text.\r\n * Doesn't guarantee that the extracted phone number\r\n * is a valid phone number (for example, doesn't validate its length).\r\n * @param  {string} text\r\n * @param  {boolean} [extract] — If `false`, then will parse the entire `text` as a phone number.\r\n * @param  {boolean} [throwOnError] — By default, it won't throw if the text is too long.\r\n * @return {string}\r\n * @example\r\n * // Returns \"(213) 373-4253\".\r\n * extractFormattedPhoneNumber(\"Call (213) 373-4253 for assistance.\")\r\n */\n\nfunction extractFormattedPhoneNumber(text, extract, throwOnError) {\n  if (!text) {\n    return;\n  }\n\n  if (text.length > MAX_INPUT_STRING_LENGTH) {\n    if (throwOnError) {\n      throw new ParseError('TOO_LONG');\n    }\n\n    return;\n  }\n\n  if (extract === false) {\n    return text;\n  } // Attempt to extract a possible number from the string passed in\n\n\n  var startsAt = text.search(PHONE_NUMBER_START_PATTERN);\n\n  if (startsAt < 0) {\n    return;\n  }\n\n  return text // Trim everything to the left of the phone number\n  .slice(startsAt) // Remove trailing non-numerical characters\n  .replace(AFTER_PHONE_NUMBER_END_PATTERN, '');\n}\n/**\r\n * @param  {string} text - Input.\r\n * @param  {boolean} v2 - Legacy API functions don't pass `v2: true` flag.\r\n * @param  {boolean} [extract] - Whether to extract a phone number from `text`, or attempt to parse the entire text as a phone number.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\n\n\nfunction parseInput(text, v2, extract) {\n  // Parse RFC 3966 phone number URI.\n  if (text && text.indexOf('tel:') === 0) {\n    return parseRFC3966(text);\n  }\n\n  var number = extractFormattedPhoneNumber(text, extract, v2); // If the phone number is not viable, then abort.\n\n  if (!number) {\n    return {};\n  }\n\n  if (!isViablePhoneNumber(number)) {\n    if (isViablePhoneNumberStart(number)) {\n      return {\n        error: 'TOO_SHORT'\n      };\n    }\n\n    return {};\n  } // Attempt to parse extension first, since it doesn't require region-specific\n  // data and we want to have the non-normalised number here.\n\n\n  var withExtensionStripped = extractExtension(number);\n\n  if (withExtensionStripped.ext) {\n    return withExtensionStripped;\n  }\n\n  return {\n    number: number\n  };\n}\n/**\r\n * Creates `parse()` result object.\r\n */\n\n\nfunction result(country, nationalNumber, ext) {\n  var result = {\n    country: country,\n    phone: nationalNumber\n  };\n\n  if (ext) {\n    result.ext = ext;\n  }\n\n  return result;\n}\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber — Example: \"(213) 373-4253\".\r\n * @param {string} [defaultCountry]\r\n * @param {string} [defaultCallingCode]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\n\n\nfunction parsePhoneNumber(formattedPhoneNumber, defaultCountry, defaultCallingCode, metadata) {\n  // Extract calling code from phone number.\n  var _extractCountryCallin = extractCountryCallingCode(parseIncompletePhoneNumber(formattedPhoneNumber), defaultCountry, defaultCallingCode, metadata.metadata),\n      countryCallingCode = _extractCountryCallin.countryCallingCode,\n      number = _extractCountryCallin.number; // Choose a country by `countryCallingCode`.\n\n\n  var country;\n\n  if (countryCallingCode) {\n    metadata.selectNumberingPlan(countryCallingCode);\n  } // If `formattedPhoneNumber` is in \"national\" format\n  // then `number` is defined and `countryCallingCode` isn't.\n  else if (number && (defaultCountry || defaultCallingCode)) {\n    metadata.selectNumberingPlan(defaultCountry, defaultCallingCode);\n\n    if (defaultCountry) {\n      country = defaultCountry;\n    } else {\n      /* istanbul ignore if */\n      if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\n        if (metadata.isNonGeographicCallingCode(defaultCallingCode)) {\n          country = '001';\n        }\n      }\n    }\n\n    countryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata);\n  } else return {};\n\n  if (!number) {\n    return {\n      countryCallingCode: countryCallingCode\n    };\n  }\n\n  var _extractNationalNumbe = extractNationalNumber(parseIncompletePhoneNumber(number), metadata),\n      nationalNumber = _extractNationalNumbe.nationalNumber,\n      carrierCode = _extractNationalNumbe.carrierCode; // Sometimes there are several countries\n  // corresponding to the same country phone code\n  // (e.g. NANPA countries all having `1` country phone code).\n  // Therefore, to reliably determine the exact country,\n  // national (significant) number should have been parsed first.\n  //\n  // When `metadata.json` is generated, all \"ambiguous\" country phone codes\n  // get their countries populated with the full set of\n  // \"phone number type\" regular expressions.\n  //\n\n\n  var exactCountry = getCountryByCallingCode(countryCallingCode, nationalNumber, metadata);\n\n  if (exactCountry) {\n    country = exactCountry;\n    /* istanbul ignore if */\n\n    if (exactCountry === '001') {// Can't happen with `USE_NON_GEOGRAPHIC_COUNTRY_CODE` being `false`.\n      // If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` is set to `true` for some reason,\n      // then remove the \"istanbul ignore if\".\n    } else {\n      metadata.country(country);\n    }\n  }\n\n  return {\n    country: country,\n    countryCallingCode: countryCallingCode,\n    nationalNumber: nationalNumber,\n    carrierCode: carrierCode\n  };\n}\n//# sourceMappingURL=parse_.js.map"]},"metadata":{},"sourceType":"module"}